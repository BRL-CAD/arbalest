CODING STYLE & STANDARDS
------------------------

For anyone who plans on contributing code, the following conventions
should be followed.  Contributions that do not conform are likely to
be ridiculed and rejected until they do.  ;-)

Violations of these rules in the existing code are not excuses to
follow suit.  If code is seen that doesn't conform, it may and should
be fixed.

Code Organization:

Code that is potentially useful to another application, or that may be
abstracted in such a way that it is useful to other applications,
should be put in a library and not in application directories.

C files use the .c extension.  Header files use the .h extension.  C++
files use the .cpp extension.  PHP files use the .php extension.
Tcl/Tk files use the .tcl/.tk extensions.  POSIX Bourne-style shell
scripts use the .sh extension.  Perl files use the .pl (program) or
.pm (module) extensions.

Source files go into the src/ directory on the top level, into a
corresponding directory for the category of binary or library that it
belongs to.  Documentation files go into the doc/ directory on the top
level, with the exception of manual (man) pages that should be
colocated with any corresponding source files.

Header files private to a library go into that library's directory.
Public header files go into the include/ directory on the top level.
Public header files should not include any headers that are private.
Headers should include any other headers required for correct parsing.
Public header files should not include the common header.

Headers should generally be included in a particular order:

  - any single "interface" header [optional]
  - the common header (unless the interface header includes it)
  - system headers
  - public headers
  - private headers

Applications may optionally provide an interface header that defines
common structures applicable to most or all files being compiled for
that application.  That interface header will generally be the first
file to be included as it usually includes the common header and
system headers.

The common header should always be included before any system header.

Standard system headers should be included before library system
headers.  Headers should be written to be self-contained, not
requiring other headers be included.  If another header is necessary
for a header to function correctly, it should include it.

Build System:

The CMake build system (more specifically, compilation test macros
defined in misc/CMake/BRLCAD_CheckFunctions.cmake) should be used
extensively to test for availability of system services such as
standard header files, available libraries, and data types.  No
assumptions should be made regarding the availability of any
particular header, function, datatype, or other resource.  After
running cmake, there will be an autogenerated include/brlcad_config.h
file that contains many preprocessor directives and type declarations
that may be used where needed.

Generic platform checks (e.g. #ifdef unix, #ifdef _WIN32) are highly
discouraged and should generally not be used.  Replace system checks
with tests for the actual facility being utilized instead.

The Windows platform utilizes its own manually-generated configure
results header (include/config_win.h) that has to be manually updated
if new tests are added to the CMake build logic.

Only the BRL-CAD sources should include and utilize the common.h
header.  They should not include brlcad_config.h or config_win.h
directly.  If used, the common.h header should be listed before any
system headers.

Language Compliance:

Features of C that conform to the ISO/IEC 9899:2011 C standard (C11)
and the ISO/IEC 14882:2011 C++ standard (C++11) are generally the
baseline for strict language conformance, with the caveat that
features deprecated in subsequent standards or not widely/reliably
implemented on OS/compiler platforms targeted by BRL-CAD should be
avoided.  When writing in C coders should keep their code within the
subset of C shared by the C and C++ standards - while not currently
strictly enforced, full C++ only build support is a long term project
goal.

Code Conventions:

Globals variables, structures, classes, and other public data
containers are highly discouraged within application code.  Do not add
any new globals to existing libraries.  Globals are often a quick
solution to some deeper coding problem.  However, they carry
significant maintenance costs, introduce (spaghetti) code complexity,
make multi-threading support more costly, pollute public API
(symbol-wise at a minimum), increase security risks, are error-prone
to use, and usually complicate refactoring and code restructuring in
the future.  Using static variables (whether function- or
static/file-scoped) is a viable alternative.  Restructuring the logic
to not be stateful is even better.

Functions should always specify a return type, including functions
that return int or void.  ANSI C prototypes should be used to declare
functions, not K&R function prototypes.

Exact floating point comparisons are unreliable without requiring
IEEE-compliant floating point math, but BRL-CAD does not require such
math for portability and performance reasons.  When floating point
comparisons are necessary, use the NEAR_EQUAL and NEAR_ZERO macros
with a specified tolerance or the EQUAL and ZERO macros where a
tolerance is indeterminate (all the macros are available by including
vmath.h).  Examples:

  For known tolerances:

  * instead of "foo == 2.0" use "NEAR_EQUAL(foo, 2.0, tol)"
  * instead of "foo != 0.0" use "foo !NEAR_ZERO(foo, tol)"

  For indeterminate tolerances:

  * instead of "foo == 2.0" use "EQUAL(foo, 2.0)"
  * instead of "foo != 0.0" use "foo !ZERO(foo)"

There are several functions whose functionality are either wrapped or
implemented in a cross-platform manner by libbu.  This includes
functions related to memory allocation, command option parsing,
logging routines, and more.  The following functions and global
variables should be utilized instead of the standard C facility:

  bu_malloc() instead of malloc()
  bu_calloc() instead of calloc()
  bu_realloc() instead of realloc()
  bu_free() instead of free()

  bu_bomb() instead of abort()
  bu_exit() instead of printf()+exit()
  bu_snooze() instead of sleep(), usleep(), nanosleep()

  bu_getopt() instead of getopt()
  bu_opterr instead of opterr
  bu_optind instead of optind
  bu_optopt instead of optopt
  bu_optarg instead of optarg

  bu_file_delete() instead of unlink(), rmdir(), and remove()
  bu_path_basename() instead of basename()
  bu_path_dirname() instead of dirname()
  bu_path_match() instead of fnmatch()

  bu_log() instead of printf()
  bu_fgets() instead of fgets()
  bu_sort() instead of qsort()

  bu_strdup() instead of strdup()
  bu_strlcat() instead of strcat(), strncat(), and strlcat()
  bu_strlcpy() instead of strcpy(), strncpy(), and strlcpy()
  bu_strcmp() and BU_STR_EQUAL() instead of strcmp()
  bu_strcasecmp() and BU_STR_EQUIV() instead of stricmp()/strcasecmp()
  bu_strncmp() instead of strncmp()
  bu_strcasecmp() instead of strnicmp()/strncasecmp()

Similarly, ANSI C functions are preferred over the BSD and POSIX
interfaces.  The following functions should be used:

  memset() instead of bzero()
  memcpy() instead of bcopy()

The code should strive to achieve conformance with the GNU coding
standard with a few exceptions.  One such exception is NOT utilizing
the GNU indentation style, but instead utilizing the BSD KNF
indentation style which is basically the K&R indentation style with 4
character indents.  The following examples should be strictly adhered
to, if only for the sake of being consistent.

1) Indentation whitespace

Indents are 4 characters, tabs are 8 characters.  There should be an
emacs and vi local variables block setting at the end of each file to
adopt, enforce, and otherwise remind one of this convention.  The
following lines should be in all C and C++ source and header files at
the end of the file:

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * indent-tabs-mode: t
 * c-file-style: "stroustrup"
 * End:
 * ex: shiftwidth=4 tabstop=8
 */

In emacs, the 'indent-region' command (bound to C-M-\ by default)
does a good job of making the needed changes to conform to this
convention.  Vi can be configured to respect the ex: modeline by
adding 'set modeline=1' to your .vimrc configuration file.  Microsoft
Visual Studio should have tabs size set to 8 and indent size set to 4
with tabs kept under Tools -> Options -> Text Editor -> C/C++ -> Tabs.
The exTabSettings project will also make MSVC conform by reading our
file footers.

A similar block can be used on source and script files in other
languages (such as Tcl, Shell, Perl, etc.).  See the local variable
footer script in sh/footer.sh to automatically set/update files.

Here is an example where '.' represents a literal space character
(0x20) and '[ ]' represents a literal tab character (0x09):

int
main(int ac, char *av[])
{
....int i;
....int foo = 0;

....for (i = 0 ; i < 10; i++) {
[      ]foo += 1;
[      ]if (foo % 2) {
[      ]....printf("hello\n");
[      ]....if (foo > 5) {
[      ][      ]printf("world\n");
[      ]....}
[      ]}
....}
....return 0;
}

We may change this at some point in the future, but this is the style
for now.  If this is confusing, use spaces to indent and run sh/ws.sh
to convert spaces to tabs.  We value consistency in order to preserve
maintainability.

2) Stylistic whitespace

No space immediately inside parentheses.
  while (1) { ...                   /* ok */
  for (i = 0; i < max; i++) { ...   /* ok */
  while ( max ) { ...               /* discouraged */

Commas and semicolons are followed by whitespace.
  int main(int argc, char *argv[]); /* ok */
  for (i = 0; i < max; i++) { ...   /* ok */

Operators and arguments generally are separated with whitespace.
  if (FLAG & MORE_FLAGS) { ...      /* ok */
  for (i = 0; i < max; i++) { ...   /* ok */
  if (FLAG&MORE_FLAGS) { ...        /* discouraged */
  for (i=0; i<max; i++) { ...       /* discouraged */

No space on arrow operators.
  structure->member = 5;            /* ok */
  structure -> member = 5;          /* bad */

Native language statements (if, while, for, switch, and return)
have a separating space, functions do not.
  int my_function(int i);           /* ok, no space */
  while (argc--) ...                /* ok, has space */
  if( var == val )                  /* discouraged */
  switch(foo) ...                   /* discouraged */

Comments should have an interior space and be without tabs.
  /** good single-line doxygen */
  /* good */
  /*bad*/
  /*	discouraged */
  /*  discouraged  */
  /**
   * good:
   * multiple-line doxygen comment
   */

3) Braces

BRL-CAD uses the "The One True Brace Style" from BSD KNF and K&R.
Opening braces should be on the same line as their statement, closing
braces should line up with that same statement.  Functions, however,
are treated specially and we place their opening braces on separate
lines.  See http://en.wikipedia.org/wiki/Indent_style for details.

  int
  some_function(char *j)
  {
      for (i = 0; i < 100; i++) {
	  if (i % 10 == 0) {
	      j += 1;
	  } else {
	      j -= 1;
	  }
      }
  }

4) Names

Variable and public API function names should almost always begin with
a lowercase letter.
  double localVariable; /* ok */
  double LocalVariable; /* bad (looks like class or constructor) */
  double _localVar;     /* bad (looks like member variable)      */

Variables are not to be "decorated" to show their type (i.e., do not
use Hungarian notation or variations thereof) with a slight exception
for pointers on occasion.  The name should use a concise, meaningful
name that is not cryptic (typing a descriptive name is preferred over
someone else hunting down what was meant).
  char *name;    /* ok  */
  char *pName;   /* discouraged for new code, but okay */
  char *fooPtr;  /* bad */
  char *lpszFoo; /* bad */

Constants should be all upper-case with word boundaries optionally
separated by underscores.
  static const int MAX_READ = 2;  /* ok  */
  static const int arraySize = 8; /* bad */

Public API (global) function names are in lowercase with underscores
to separate words.  Most functions within the core libraries are named
with the following convention: [library]_[group]_[action]
  bu_vls_strcat()
  bn_mat_transpose()

Naming exceptions are allowed where the API intentionally mirrors some
other familiar programming construct (e.g., bu_malloc()+bu_free()),
but care should otherwise be taken to be as consistent as possible
within a file and across a library's API.

Here are some naming convention pairings commonly used:

  Allocation   => alloc()
  Deallocation => free()

  Initialization      => init()
  De/Reinitialization => clear()

  Allocation + Init      => create()   (new for C++)
  Deinitialize + Dealloc => destroy()  (delete for C++)

  Resource acquire => open()
  Resource release => close()

5) Debugging

Compilation preprocessor defines should never change the size of
structures.
  struct Foo {
  #ifdef DEBUG_CODE  // bad
    int _magic;
  #endif
  };

6) Comments

"//" style comments are not allowed in C source files for portability.
Comment blocks should utilize an asterisk at the beginning of each new
line.  Doxygen comments should start on the second line unless it's a
succinct /** single-line */ comment.

/* This is a
 * comment block.
 */

/**
 * This is a doxygen comment.
 */

7) Line length

We do not impose a fixed line length for source code.  Comments blocks
are formatted to column 70.

Long 'if' statements and function prototypes are okay.  Expressions
and function arguments are sometimes separated one per line where it
helps readability, but reducing the complexity of expressions and
number of function arguments is usually better.
